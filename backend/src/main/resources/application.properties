server.port=8080

# Debug logging for database connection issues
logging.level.com.zaxxer.hikari=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql=TRACE
logging.level.org.springframework.jdbc=DEBUG

# Print all environment variables on startup - for debugging
logging.level.com.hackathon.socomsci=DEBUG

# Database Configuration with Railway's auto-provided variables
spring.datasource.url=jdbc:postgresql://${PGHOST:localhost}:${PGPORT:5432}/${PGDATABASE:postgres}
spring.datasource.username=${PGUSER:postgres}
spring.datasource.password=${PGPASSWORD:postgres}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.connectionTimeout=20000
spring.datasource.hikari.maximumPoolSize=10
spring.datasource.hikari.minimumIdle=5
spring.datasource.hikari.idleTimeout=300000
spring.datasource.hikari.maxLifetime=1200000

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Development only settings - overridden by Railway profile in production
spring.jpa.hibernate.ddl-auto=${JPA_DDL_AUTO:create}
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# Critical for proper initialization order: create schema first, then run SQL files
spring.jpa.defer-datasource-initialization=true

# Data initialization - disabled for production unless needed
spring.sql.init.mode=${INIT_MODE:always}
spring.sql.init.platform=postgresql
spring.sql.init.data-locations=classpath:data.sql
spring.sql.init.continue-on-error=false

gemini.api.key=
gemini.api.url=https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-001:generateContent

# CORS configuration with Railway frontend URL support
spring.web.cors.allowed-origins=${FRONTEND_URL:http://localhost:3000}
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true